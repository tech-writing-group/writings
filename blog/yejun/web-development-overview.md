---
slug: web-development-overview
title: Overview of Web Development
authors: yejun
unlisted: true
---

# 문제 의식

## 1. 잘못된 로드맵

기술 Stack 이름 (해결책) 위주의 로드맵이 많아, 실제로 웹 개발을 잘하기 위해 필요한 본질이 무엇인지 흐려진다.

깊게 공부하고 알아야 할 것은 (CS 지식, 디버깅 잘 하는 방법론, 스택을 빠르게 학습하는 방법 등) 따로 있다
하지만 간단하지만 잘 모르는 키워드를 나열함으로서 어렵게 보이고, 할 일이 많아 보이도록 만들고 있다.
기술 스택은 핵심이 아니며, 개발자의 본질은 다른 곳에 있다.

웹 개발자의 본질은, 특히 스타트업 씬에서 중요한 것은 따로 있다.

1. 정말 현재 상황에 유용한 것이 무엇인지 파악하는 것
2. 이를 통해 빠르고 정확하게 가치를 만드는데 있다.

이 두 개를 잘 하려면 왜 유용한지, 어떤 가치를 만드는지 파고들고 이해하려고 노력해야 한다.

## 2. 한 눈에 보기 쉽게 정리된 자료의 부재

웹 개발을 배우기 위해서 알아야 할 것을 한 눈에 파악할 수 있는 자료가 없다.

특히 1번 문제와 결부되어, 왜 특정 스택이 중요한지 알 수 없고, 수없이 많은 기술 스택의 수에 압도된다.
따라서, 어렵지도 않은 것을 어렵다고 느끼기 쉽다.

# 접근 방식

## 1. 문제의 해결책 혹은 스택이 아니라 문제 자체의 패턴과 이름을 식별한다

react, react query, nextjs 다 좋지만 결국 이 프레임워크가 등장한 배경과 해결하고자 하는 바를 알아야 한다.

업계에서는 끊임없이 새로운 것이 나오고 트렌트가 바뀌기 마련.

문제를 제대로 이해하지 않으면 배워야 할 것에 파묻혀 버린다.

무엇을 배울지 무엇을 배우지 않아도 되는지. 지금 상황에서 필요한 것인지를 이해할 수 있어야 한다.

## 2. 개론와 큰 그림 위주로 설명한다

전체 / 프론트엔드 / 백엔드 별로 접근하기 쉽게 최대한 쉽게 설명하되, 필요하면 더 깊이 파고들수 있는 여지를 제공한다.

GoF Design Pattern 책 처럼 패턴의 이름, 배경, 해결 방법, 레퍼런스 등을 제공한다.

왜 그렇게 되는지 어떻게 활용해야 하는지에 대한 방법은 다른 자료를 언급하거나, 다른 글의 주제로 다룬다.

# 01. 개론

- 서비스 개발이라는 전체 그림과 개발자의 역할
- 프론트와 백엔드가 나뉘는 이유
- 프론트와 백엔드 구분이 의미 없는 경우
- 생산성 문제: 모든 스택에서 겪는 공통된 문제
  - 스택 자체를 잘 쓴다고 개발자가 되는 것이 아니다.
  - 스택을 잘 쓰면 정확하고 효율적인 방법을 알겠지만 그 외 일반적인 문제 또한 존재한다.
  - 의사소통에 의한 생산성
  - 코드의 관리 수준에 의한 생산성
- 문제 해결에 집중하기: 특정 기술 스택이 중요하지 않은 이유

# 02. Presentation / State 동기화 문제: 프론트엔드와 백엔드의 경계 정하기

## Background / Problem

- Presentation Layer
  - 기본적으로 서비스와 사람이 소통하려면 Interface가 필요해진다.
  - 이때 사용하는 것이 Presentation Layer임
- State (Business Logic) Layer
  - 서비스는 입력 출력만 필요한 계산기가 아닌 이상에야 어떤 상태를 가지고 있기 마련임.
  - 현재 상태를 State라고 하며, 상태가 변화할 수 있는 관련 규칙을 Business Logic이라고 함
  - 보통 서비스는 제공하는 자원 (실제 물리적, 금전적 가치를 지녔거나, 정보로써의 가치, 서비스 이용권, 다른 사람의 정보 등)이 있다.
  - 이 자원과 규칙을 관리하는 것이 State Layer임
- State 관리 전략
  - 백업: 편의상 사용자의 정보를 원격에 백업처럼 저장하는 경우가 있음
  - 최신 상태와 규칙 유지
    - State와 Business Logic을 한 장소에서 최신의 올바른 상태로 유지하고 싶은 경우가 있음
    - 이 때, 보여주기 위한 부분과 실제로 정보를 저장하는 부분이 분리되곤 함
    - 예를 들어, 게시판의 글 목록은 다른 사람에게도 보여줘야 하므로, 이를 저장하는 부분 (원격 서버)와 보여주는 부분(클라이언트)가 분리됨

## Solutions

- Pure Client Side: 클라이언트에서 State 관리
- Thin Client / Pure SSR: 서버에서 State 관리
- Replicated State (CSR) / Original State in Server: Client Side에서 State 관리
- Hybrid (SSR + CSR): Hydration이라는 과정을 통해 Interactivity는 Client로 구현
